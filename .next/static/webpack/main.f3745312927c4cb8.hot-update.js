"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createKey: function() {\n        return createKey;\n    },\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js\"));\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"./node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _constants = __webpack_require__(/*! ../../../lib/constants */ \"./node_modules/next/dist/lib/constants.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/') || false) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites }] = param;\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  true ? undefined : 0,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (true) {\n                    const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, (path)=>resolveDynamicRoute(path, pages), options.router.locales);\n                    if (result.matchedPage) {\n                        parsedRewriteTarget.pathname = result.parsedAs.pathname;\n                        as = parsedRewriteTarget.pathname;\n                        Object.assign(parsedRewriteTarget.query, result.parsedAs.query);\n                    }\n                } else {}\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        });\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            });\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: \"\" + pathname + src.query + src.hash,\n                newUrl: \"\" + pathname + src.query + src.hash\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n    };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    const getData = (params)=>{\n        var _params_method;\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: 'prefetch'\n            } : {}, isPrefetch && hasMiddleware ? {\n                'x-middleware-prefetch': '1'\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : 'GET'\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== 'production' || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === 'Failed to fetch' || // firefox\n            err.message === 'NetworkError when attempting to fetch resource.' || // safari\n            err.message === 'Load failed') {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n                // only update cache if not marked as no-cache\n                inflightCache[cacheKey] = Promise.resolve(data);\n            }\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url, router } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route, router } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options) {\n        if (options === void 0) options = {};\n        if (false) {}\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options) {\n        if (options === void 0) options = {};\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            if (!this._bfl_s && !this._bfl_d) {\n                const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\");\n                let staticFilterData;\n                let dynamicFilterData;\n                try {\n                    ;\n                    ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());\n                } catch (err) {\n                    // failed to load build manifest hard navigate\n                    // to be safe\n                    console.error(err);\n                    if (skipNavigate) {\n                        return true;\n                    }\n                    handleHardNavigation({\n                        url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routerFilterSValue = {\"numItems\":2,\"errorRate\":0.0001,\"numBits\":39,\"numHashes\":14,\"bitArray\":[0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1,0,1]};\n                if (!staticFilterData && routerFilterSValue) {\n                    staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n                }\n                const routerFilterDValue = {\"numItems\":1,\"errorRate\":0.0001,\"numBits\":20,\"numHashes\":14,\"bitArray\":[1,1,1,1,0,0,0,0,0,1,0,1,0,1,1,0,1,0,1,0]};\n                if (!dynamicFilterData && routerFilterDValue) {\n                    dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n                }\n                if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                    this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                    this._bfl_s.import(staticFilterData);\n                }\n                if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                    this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                    this._bfl_d.import(dynamicFilterData);\n                }\n            }\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            const pathsToCheck = [\n                {\n                    as\n                },\n                {\n                    as: resolvedAs\n                }\n            ];\n            for (const { as: curAs, allowMatchCurrent } of pathsToCheck){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n                        var _this__bfl_s, _this__bfl_s1;\n                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split('/');\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                var _this__bfl_d;\n                                const currentPart = curAsParts.slice(0, i).join('/');\n                                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        var _this_components_pathname;\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) { var _this_locales; }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            ;\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== '/_error') {\n            ;\n            options._shouldResolveHref = true;\n            if ( true && as.startsWith('/')) {\n                const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n                if (rewritesResult.externalDest) {\n                    handleHardNavigation({\n                        url: as,\n                        router: this\n                    });\n                    return true;\n                }\n                if (!isMiddlewareMatch) {\n                    resolvedAs = rewritesResult.asPath;\n                }\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(', ') + \" in the `href`'s `query`\"));\n                    }\n                    throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(', ') + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as')));\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit('routeChangeStart', as, routeProps);\n        }\n        const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n        try {\n            var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if ('route' in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if ('type' in routeInfo) {\n                if (routeInfo.type === 'redirect-internal') {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if ('type' in routeInfo) {\n                        throw new Error(\"Unexpected middleware effect on /404\");\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === '/_error' && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            var _routeInfo_route;\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n            var _options_scroll;\n            const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if ('type' in routeInfo) {\n                    throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n                }\n                if (this.pathname === '/_error' && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit('routeChangeComplete', as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options) {\n        if (options === void 0) options = {};\n        if (true) {\n            if (typeof window.history === 'undefined') {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(\"Warning: window.history.\" + method + \" is not available\");\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        console.error(err);\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent('/_error');\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(param) {\n        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            var _data_effect, _data_effect1, _data_effect2, _data_response;\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && \"development\" !== 'development' ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? '/404' : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === '/_error' || pathname === '/404')) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === 'redirect-internal' || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === 'redirect-external') {\n                return data.effect;\n            }\n            if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === 'rewrite') {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                }\n            }\n            const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get('x-middleware-skip');\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== 'development' && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n        const [newUrlNoHash, newHash] = as.split('#', 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#', 2);\n        (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === '' || hash === 'top') {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath, options) {\n        if (asPath === void 0) asPath = url;\n        if (options === void 0) options = {};\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if ( true && asPath.startsWith('/')) {\n            let rewrites;\n            ({ __rewrites: rewrites } = await (0, _routeloader.getClientBuildManifest)());\n            const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages), this.locales);\n            if (rewritesResult.externalDest) {\n                return;\n            }\n            if (!isMiddlewareMatch) {\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n            }\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n            }\n        }\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === 'rewrite') {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === 'redirect-external') {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !true);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    // if middleware matches we leave resolving to the change function\n                    // as the server needs to resolve for correct priority\n                    ;\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n}\nRouter.events = (0, _mitt.default)(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiNEJBQTRCOzs7Ozs7Ozs7Ozs7O0lBcW1CWkEsU0FBUztlQUFUQTs7O2VBaURLQzs7SUEzakJDQyxpQkFBaUI7ZUFBakJBOzs7OztpREFqRmM7eUNBSzdCO29DQUNnQzsrRUFDQztpREFDSjtpREFDQTsyRUFDbkI7bUNBQ2tEO3VDQUNwQzs4Q0FDRTtzRkFDTDswQ0FDSTt3Q0FDRjt1Q0FDTztnREFDRjt1Q0FDVDt1Q0FDQTswQ0FDRzs0Q0FDRTt5Q0FDSDt5Q0FDQTt5Q0FDQTt3Q0FDRDtpREFDUztvREFDRzsyQ0FDSDt3Q0FDVDttQ0FDTDtrQ0FDRDsyQ0FDUztnREFDSzt1Q0FFQztBQWdDcEMsU0FBU0M7SUFDUCxPQUFPQyxPQUFPQyxNQUFNLENBQUMsSUFBSUMsTUFBTSxvQkFBb0I7UUFDakRDLFdBQVc7SUFDYjtBQUNGO0FBU08sZUFBZUwsa0JBQ3BCTSxPQUFrQztJQUVsQyxNQUFNQyxXQUFXLE1BQU1DLFFBQVFDLE9BQU8sQ0FDcENILFFBQVFJLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDQyxhQUFhO0lBRXpDLElBQUksQ0FBQ0wsVUFBVSxPQUFPO0lBRXRCLE1BQU0sRUFBRU0sVUFBVUMsVUFBVSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLFdBQUFBLFNBQVMsRUFBQ1QsUUFBUVUsTUFBTTtJQUN6RCw2RkFBNkY7SUFDN0YsTUFBTUMsWUFBWUMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWUosY0FDMUJLLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFBQSxFQUFlTCxjQUNmQTtJQUNKLE1BQU1NLDBCQUEwQkMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFDOUJDLENBQUFBLEdBQUFBLFdBQUFBLFNBQUFBLEVBQVVMLFdBQVdYLFFBQVFpQixNQUFNO0lBR3JDLDJFQUEyRTtJQUMzRSx1RUFBdUU7SUFDdkUsT0FBT2hCLFNBQVNpQixJQUFJLENB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LDJEQUEyRDtnQkFDM0QsNERBQTREO2dCQUM1RCxNQUFNM0IsVUFBNkI7b0JBQUVpQjtnQkFBTztnQkFDNUMsTUFBTVAsU0FBU3NULENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBO2dCQUVmLElBQUksQ0FBQ21GLGdDQUFnQyxHQUFHelosa0JBQWtCO29CQUN4RFUsUUFBUSxJQUFJO29CQUNaYTtvQkFDQVA7Z0JBQ0YsR0FBR21FLElBQUksQ0FBQyxDQUFDYztvQkFDUCxrRUFBa0U7b0JBQ2xFLHNEQUFzRDs7b0JBQ3BEM0YsUUFBZ0J5TixrQkFBa0IsR0FBRzFMLE9BQU94QjtvQkFFOUMsSUFBSSxDQUFDaVAsV0FBVyxDQUNkLGdCQUNBN0osVUFDSWpGLFNBQ0F5TixDQUFBQSxHQUFBQSxXQUFBQSxvQkFBQUEsRUFBcUI7d0JBQ25CNU4sVUFBVVEsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWVI7d0JBQ3RCK0U7b0JBQ0YsSUFDSjVFLFFBQ0FWO29CQUVGLE9BQU8yRjtnQkFDVDtZQUNGO1lBRUFzQixPQUFPbVMsZ0JBQWdCLENBQUMsWUFBWSxJQUFJLENBQUNkLFVBQVU7WUFFbkQsMkRBQTJEO1lBQzNELG1EQUFtRDtZQUNuRCxJQUFJNVUsS0FBcUMsRUFBRSxFQUkxQztRQUNIO0lBQ0Y7QUF3ckRGO0FBaDREcUJqRSxPQTZDWjBQLE1BQUFBLEdBQW1DbUssQ0FBQUEsR0FBQUEsTUFBQUEsT0FBSSIsInNvdXJjZXMiOlsiL3NyYy9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IERvbWFpbkxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgdHlwZSB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUm91dGVyRXZlbnQgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB0eXBlIFBhZ2VMb2FkZXIgZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBBcHBDb250ZXh0VHlwZSwgTmV4dFBhZ2VDb250ZXh0LCBORVhUX0RBVEEgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHJlbW92ZVRyYWlsaW5nU2xhc2ggfSBmcm9tICcuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7XG4gIGdldENsaWVudEJ1aWxkTWFuaWZlc3QsXG4gIGlzQXNzZXRFcnJvcixcbiAgbWFya0Fzc2V0RXJyb3IsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXInXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRTY3JpcHRMb2FkIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3NjcmlwdCdcbmltcG9ydCBpc0Vycm9yLCB7IGdldFByb3BlckVycm9yIH0gZnJvbSAnLi4vLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5pbXBvcnQgbWl0dCBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4sIGdldFVSTCwgbG9hZEdldEluaXRpYWxQcm9wcywgU1QgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHJlc29sdmVSZXdyaXRlcyBmcm9tICcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcbmltcG9ydCB7IGZvcm1hdFdpdGhWYWxpZGF0aW9uIH0gZnJvbSAnLi91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgZGV0ZWN0RG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlJ1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi91dGlscy9wYXJzZS1wYXRoJ1xuaW1wb3J0IHsgYWRkTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2FkZC1sb2NhbGUnXG5pbXBvcnQgeyByZW1vdmVMb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGgnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IHJlc29sdmVIcmVmIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3Jlc29sdmUtaHJlZidcbmltcG9ydCB7IGlzQVBJUm91dGUgfSBmcm9tICcuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlJ1xuaW1wb3J0IHsgZ2V0TmV4dFBhdGhuYW1lSW5mbyB9IGZyb20gJy4vdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mbydcbmltcG9ydCB7IGZvcm1hdE5leHRQYXRobmFtZUluZm8gfSBmcm9tICcuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyBjb21wYXJlUm91dGVyU3RhdGVzIH0gZnJvbSAnLi91dGlscy9jb21wYXJlLXN0YXRlcydcbmltcG9ydCB7IGlzTG9jYWxVUkwgfSBmcm9tICcuL3V0aWxzL2lzLWxvY2FsLXVybCdcbmltcG9ydCB7IGlzQm90IH0gZnJvbSAnLi91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnLi91dGlscy9vbWl0J1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVBcyB9IGZyb20gJy4vdXRpbHMvaW50ZXJwb2xhdGUtYXMnXG5pbXBvcnQgeyBoYW5kbGVTbW9vdGhTY3JvbGwgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsJ1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5pbXBvcnQgeyBNQVRDSEVEX1BBVEhfSEVBREVSIH0gZnJvbSAnLi4vLi4vLi4vbGliL2NvbnN0YW50cydcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAvKiBwcm9kICovXG4gICAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIH1cbn1cblxuaW50ZXJmYWNlIFJvdXRlUHJvcGVydGllcyB7XG4gIHNoYWxsb3c6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcbiAgc2Nyb2xsPzogYm9vbGVhblxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG5leHBvcnQgdHlwZSBIaXN0b3J5U3RhdGUgPVxuICB8IG51bGxcbiAgfCB7IF9fTkE6IHRydWU7IF9fTj86IGZhbHNlIH1cbiAgfCB7IF9fTjogZmFsc2U7IF9fTkE/OiBmYWxzZSB9XG4gIHwgKHsgX19OQT86IGZhbHNlOyBfX046IHRydWU7IGtleTogc3RyaW5nIH0gJiBOZXh0SGlzdG9yeVN0YXRlKVxuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5pbnRlcmZhY2UgTWlkZGxld2FyZUVmZmVjdFBhcmFtczxUIGV4dGVuZHMgRmV0Y2hEYXRhT3V0cHV0PiB7XG4gIGZldGNoRGF0YT86ICgpID0+IFByb21pc2U8VD5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGFzUGF0aDogc3RyaW5nXG4gIHJvdXRlcjogUm91dGVyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZTxUIGV4dGVuZHMgRmV0Y2hEYXRhT3V0cHV0PihcbiAgb3B0aW9uczogTWlkZGxld2FyZUVmZmVjdFBhcmFtczxUPlxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IG1hdGNoZXJzID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKFxuICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXG4gIClcbiAgaWYgKCFtYXRjaGVycykgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSB9ID0gcGFyc2VQYXRoKG9wdGlvbnMuYXNQYXRoKVxuICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgY29uc3QgY2xlYW5lZEFzID0gaGFzQmFzZVBhdGgoYXNQYXRobmFtZSlcbiAgICA/IHJlbW92ZUJhc2VQYXRoKGFzUGF0aG5hbWUpXG4gICAgOiBhc1BhdGhuYW1lXG4gIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gYWRkQmFzZVBhdGgoXG4gICAgYWRkTG9jYWxlKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpXG4gIClcblxuICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSkgPT5cbiAgICBuZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKVxuICApXG59XG5cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcblxuICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmxcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlcjogTmV4dFJvdXRlciwgdXJsOiBVcmwsIGFzPzogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmV2FzQWJzb2x1dGUgPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pXG4gIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pXG5cbiAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKVxuICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBc1xuXG4gIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlciwgYXMpKVxuICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcblxuICByZXR1cm4ge1xuICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcyksXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZTogc3RyaW5nLCBwYWdlczogc3RyaW5nW10pIHtcbiAgY29uc3QgY2xlYW5QYXRobmFtZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2goZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSkpXG4gIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lXG4gIH1cblxuICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICBwYXRobmFtZSA9IHBhZ2VcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHJldHVybiByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxufVxuXG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YTxUIGV4dGVuZHMgRmV0Y2hEYXRhT3V0cHV0PihcbiAgc291cmNlOiBzdHJpbmcsXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgb3B0aW9uczogTWlkZGxld2FyZUVmZmVjdFBhcmFtczxUPlxuKSB7XG4gIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgYmFzZVBhdGg6IG9wdGlvbnMucm91dGVyLmJhc2VQYXRoLFxuICAgIGkxOG46IHsgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyB9LFxuICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSxcbiAgfVxuICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLXJld3JpdGUnKVxuXG4gIGxldCByZXdyaXRlVGFyZ2V0ID1cbiAgICByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1tYXRjaGVkLXBhdGgnKVxuXG4gIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoTUFUQ0hFRF9QQVRIX0hFQURFUilcblxuICBpZiAoXG4gICAgbWF0Y2hlZFBhdGggJiZcbiAgICAhcmV3cml0ZVRhcmdldCAmJlxuICAgICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnX19uZXh0X2RhdGFfY2F0Y2hhbGwnKSAmJlxuICAgICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnL19lcnJvcicpICYmXG4gICAgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCcvNDA0JylcbiAgKSB7XG4gICAgLy8gbGV2ZXJhZ2UgeC1tYXRjaGVkLXBhdGggdG8gZGV0ZWN0IG5leHQuY29uZmlnLmpzIHJld3JpdGVzXG4gICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoXG4gIH1cblxuICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgIGlmIChcbiAgICAgIHJld3JpdGVUYXJnZXQuc3RhcnRzV2l0aCgnLycpIHx8XG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkVcbiAgICApIHtcbiAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSBwYXJzZVJlbGF0aXZlVXJsKHJld3JpdGVUYXJnZXQpXG4gICAgICBjb25zdCBwYXRobmFtZUluZm8gPSBnZXROZXh0UGF0aG5hbWVJbmZvKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgcGFyc2VEYXRhOiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgbGV0IGZzUGF0aG5hbWUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lSW5mby5wYXRobmFtZSlcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLFxuICAgICAgXSkudGhlbigoW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dOiBhbnkpID0+IHtcbiAgICAgICAgbGV0IGFzID0gYWRkTG9jYWxlKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNEeW5hbWljUm91dGUoYXMpIHx8XG4gICAgICAgICAgKCFyZXdyaXRlSGVhZGVyICYmXG4gICAgICAgICAgICBwYWdlcy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChyZW1vdmVCYXNlUGF0aChhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpXG4gICAgICAgICAgICAgICAgLnBhdGhuYW1lXG4gICAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRTb3VyY2UgPSBnZXROZXh0UGF0aG5hbWVJbmZvKFxuICAgICAgICAgICAgcGFyc2VSZWxhdGl2ZVVybChzb3VyY2UpLnBhdGhuYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IG5leHRDb25maWcsXG4gICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgICBhcyA9IGFkZEJhc2VQYXRoKHBhcnNlZFNvdXJjZS5wYXRobmFtZSlcbiAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgIHJld3JpdGVzLFxuICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSxcbiAgICAgICAgICAgIChwYXRoOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLFxuICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWVcbiAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIHBhZ2VzKVxuXG4gICAgICAgICAgaWYgKHJlc29sdmVkUGF0aG5hbWUgIT09IGZzUGF0aG5hbWUpIHtcbiAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpXG4gICAgICAgICAgPyByZXNvbHZlRHluYW1pY1JvdXRlKFxuICAgICAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgICAgICAgIHJlbW92ZUJhc2VQYXRoKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgICAgICAgKS5wYXRobmFtZSxcbiAgICAgICAgICAgICAgcGFnZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGZzUGF0aG5hbWVcblxuICAgICAgICBpZiAoaXNEeW5hbWljUm91dGUocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRSb3V0ZU1hdGNoZXIoZ2V0Um91dGVSZWdleChyZXNvbHZlZEhyZWYpKShhcylcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyBhcyBjb25zdCxcbiAgICAgICAgICBwYXJzZWRBczogcGFyc2VkUmV3cml0ZVRhcmdldCxcbiAgICAgICAgICByZXNvbHZlZEhyZWYsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHNyYyA9IHBhcnNlUGF0aChzb3VyY2UpXG4gICAgY29uc3QgcGF0aG5hbWUgPSBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKHtcbiAgICAgIC4uLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7IG5leHRDb25maWcsIHBhcnNlRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICBidWlsZElkOiAnJyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICB0eXBlOiAncmVkaXJlY3QtZXh0ZXJuYWwnIGFzIGNvbnN0LFxuICAgICAgZGVzdGluYXRpb246IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YCxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmVkaXJlY3QnKVxuXG4gIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgIGlmIChyZWRpcmVjdFRhcmdldC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIGNvbnN0IHNyYyA9IHBhcnNlUGF0aChyZWRpcmVjdFRhcmdldClcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyh7XG4gICAgICAgIC4uLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7IG5leHRDb25maWcsIHBhcnNlRGF0YTogdHJ1ZSB9KSxcbiAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgYnVpbGRJZDogJycsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWludGVybmFsJyBhcyBjb25zdCxcbiAgICAgICAgbmV3QXM6IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YCxcbiAgICAgICAgbmV3VXJsOiBgJHtwYXRobmFtZX0ke3NyYy5xdWVyeX0ke3NyYy5oYXNofWAsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgdHlwZTogJ3JlZGlyZWN0LWV4dGVybmFsJyBhcyBjb25zdCxcbiAgICAgIGRlc3RpbmF0aW9uOiByZWRpcmVjdFRhcmdldCxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHR5cGU6ICduZXh0JyBhcyBjb25zdCB9KVxufVxuXG5pbnRlcmZhY2UgV2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0IGV4dGVuZHMgRmV0Y2hEYXRhT3V0cHV0IHtcbiAgZWZmZWN0OiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIGdldE1pZGRsZXdhcmVEYXRhPj5cbn1cblxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+KFxuICBvcHRpb25zOiBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQ+XG4pOiBQcm9taXNlPFdpdGhNaWRkbGV3YXJlRWZmZWN0c091dHB1dCB8IG51bGw+IHtcbiAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpXG4gIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKClcblxuICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKVxuXG4gIHJldHVybiB7XG4gICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAganNvbjogZGF0YS5qc29uLFxuICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICBlZmZlY3QsXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbG9jYWxlcz86IHN0cmluZ1tdIHwgdW5kZWZpbmVkXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZVtdIHwgdW5kZWZpbmVkXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ2ZvcndhcmQnXG4gICAgfCAncHJlZmV0Y2gnXG4gICAgfCAnYmVmb3JlUG9wU3RhdGUnXG4gICAgfCAnZXZlbnRzJ1xuICAgIHwgJ2lzRmFsbGJhY2snXG4gICAgfCAnaXNSZWFkeSdcbiAgICB8ICdpc1ByZXZpZXcnXG4gID5cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hPcHRpb25zID0ge1xuICBwcmlvcml0eT86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcbiAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID1cbiAgfCAoT21pdDxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdzdHlsZVNoZWV0cyc+ICYgeyBpbml0aWFsOiB0cnVlIH0pXG4gIHwgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbiAgcm91dGU/OiBzdHJpbmdcbiAgcmVzb2x2ZWRBcz86IHN0cmluZ1xuICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzID0gUGljazxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdDb21wb25lbnQnIHwgJ2Vycic+ICYge1xuICByb3V0ZXI6IFJvdXRlclxufSAmIFJlY29yZDxzdHJpbmcsIGFueT5cbmV4cG9ydCB0eXBlIEFwcENvbXBvbmVudCA9IENvbXBvbmVudFR5cGU8QXBwUHJvcHM+XG5cbnR5cGUgU3Vic2NyaXB0aW9uID0gKFxuICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICBBcHA6IEFwcENvbXBvbmVudCxcbiAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbikgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5ICYmXG4gICEhKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHYgPSAnX19uZXh0J1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWVcbiAgICB9IGNhdGNoIChuKSB7fVxuICB9KSgpXG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJylcblxuZnVuY3Rpb24gZmV0Y2hSZXRyeShcbiAgdXJsOiBzdHJpbmcsXG4gIGF0dGVtcHRzOiBudW1iZXIsXG4gIG9wdGlvbnM6IFBpY2s8UmVxdWVzdEluaXQsICdtZXRob2QnIHwgJ2hlYWRlcnMnPlxuKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAneC1uZXh0anMtZGF0YSc6ICcxJyxcbiAgICB9KSxcbiAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gIXJlc3BvbnNlLm9rICYmIGF0dGVtcHRzID4gMSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwXG4gICAgICA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpXG4gICAgICA6IHJlc3BvbnNlXG4gIH0pXG59XG5cbmludGVyZmFjZSBGZXRjaERhdGFPdXRwdXQge1xuICBkYXRhSHJlZjogc3RyaW5nXG4gIGpzb246IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsXG4gIHJlc3BvbnNlOiBSZXNwb25zZVxuICB0ZXh0OiBzdHJpbmdcbiAgY2FjaGVLZXk6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgRmV0Y2hOZXh0RGF0YVBhcmFtcyB7XG4gIGRhdGFIcmVmOiBzdHJpbmdcbiAgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW5cbiAgcGFyc2VKU09OOiBib29sZWFuIHwgdW5kZWZpbmVkXG4gIGhhc01pZGRsZXdhcmU/OiBib29sZWFuXG4gIGluZmxpZ2h0Q2FjaGU6IE5leHREYXRhQ2FjaGVcbiAgcGVyc2lzdENhY2hlOiBib29sZWFuXG4gIGlzUHJlZmV0Y2g6IGJvb2xlYW5cbiAgaXNCYWNrZ3JvdW5kPzogYm9vbGVhblxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIHRyeVRvUGFyc2VBc0pTT04odGV4dDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoe1xuICBkYXRhSHJlZixcbiAgaW5mbGlnaHRDYWNoZSxcbiAgaXNQcmVmZXRjaCxcbiAgaGFzTWlkZGxld2FyZSxcbiAgaXNTZXJ2ZXJSZW5kZXIsXG4gIHBhcnNlSlNPTixcbiAgcGVyc2lzdENhY2hlLFxuICBpc0JhY2tncm91bmQsXG4gIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbn06IEZldGNoTmV4dERhdGFQYXJhbXMpOiBQcm9taXNlPEZldGNoRGF0YU91dHB1dD4ge1xuICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgY29uc3QgZ2V0RGF0YSA9IChwYXJhbXM/OiB7IG1ldGhvZD86ICdIRUFEJyB8ICdHRVQnIH0pID0+XG4gICAgZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30gYXMgSGVhZGVyc0luaXQsXG4gICAgICAgIGlzUHJlZmV0Y2ggPyB7IHB1cnBvc2U6ICdwcmVmZXRjaCcgfSA6IHt9LFxuICAgICAgICBpc1ByZWZldGNoICYmIGhhc01pZGRsZXdhcmUgPyB7ICd4LW1pZGRsZXdhcmUtcHJlZmV0Y2gnOiAnMScgfSA6IHt9XG4gICAgICApLFxuICAgICAgbWV0aG9kOiBwYXJhbXM/Lm1ldGhvZCA/PyAnR0VUJyxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiBwYXJhbXM/Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YUhyZWYsIHJlc3BvbnNlLCB0ZXh0OiAnJywganNvbjoge30sIGNhY2hlS2V5IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGhhc01pZGRsZXdhcmUgJiZcbiAgICAgICAgICAgICAgWzMwMSwgMzAyLCAzMDcsIDMwOF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGRhdGFIcmVmLCByZXNwb25zZSwgdGV4dCwganNvbjoge30sIGNhY2hlS2V5IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgIGlmICh0cnlUb1BhcnNlQXNKU09OKHRleHQpPy5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgIGpzb246IHsgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORCB9LFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyb3IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFwZXJzaXN0Q2FjaGUgfHxcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8XG4gICAgICAgICAgZGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLWNhY2hlJykgPT09ICduby1jYWNoZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBjaHJvbWVcbiAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcgfHxcbiAgICAgICAgICAvLyBmaXJlZm94XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicgfHxcbiAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ0xvYWQgZmFpbGVkJ1xuICAgICAgICApIHtcbiAgICAgICAgICBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuXG4gIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtY2FjaGUnKSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjYWNoZSBpZiBub3QgbWFya2VkIGFzIG5vLWNhY2hlXG4gICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldXG4gIH1cbiAgcmV0dXJuIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoXG4gICAgaXNCYWNrZ3JvdW5kID8geyBtZXRob2Q6ICdIRUFEJyB9IDoge31cbiAgKSlcbn1cblxuaW50ZXJmYWNlIE5leHREYXRhQ2FjaGUge1xuICBbYXNQYXRoOiBzdHJpbmddOiBQcm9taXNlPEZldGNoRGF0YU91dHB1dD5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gIHVybCxcbiAgcm91dGVyLFxufToge1xuICB1cmw6IHN0cmluZ1xuICByb3V0ZXI6IFJvdXRlclxufSkge1xuICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAvLyBVUkwgYXMgdGhpcyBjYW4gZW5kIHVwIHdpdGggYW4gaW5maW5pdGUgcmVmcmVzaFxuICBpZiAodXJsID09PSBhZGRCYXNlUGF0aChhZGRMb2NhbGUocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMICR7dXJsfSAke2xvY2F0aW9uLmhyZWZ9YFxuICAgIClcbiAgfVxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxufVxuXG5jb25zdCBnZXRDYW5jZWxsZWRIYW5kbGVyID0gKHtcbiAgcm91dGUsXG4gIHJvdXRlcixcbn06IHtcbiAgcm91dGU6IHN0cmluZ1xuICByb3V0ZXI6IFJvdXRlclxufSkgPT4ge1xuICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgY29uc3QgY2FuY2VsID0gKHJvdXRlci5jbGMgPSAoKSA9PiB7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZVxuICB9KVxuXG4gIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpID0+IHtcbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICByb3V0ZXIuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlQ2FuY2VsbGVkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgc2RjOiBOZXh0RGF0YUNhY2hlID0ge31cbiAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gIHNiYzogTmV4dERhdGFDYWNoZSA9IHt9XG5cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IFBhZ2VMb2FkZXJcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyPFJvdXRlckV2ZW50PlxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgX3NoYWxsb3c/OiBib29sZWFuIHwgdW5kZWZpbmVkXG4gIGxvY2FsZXM/OiBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVbXSB8IHVuZGVmaW5lZFxuICBpc1JlYWR5OiBib29sZWFuXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG4gIGlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZVxuICBfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZTogUHJvbWlzZTxib29sZWFuPlxuICAvLyBzdGF0aWMgZW50cmllcyBmaWx0ZXJcbiAgX2JmbF9zPzogaW1wb3J0KCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykuQmxvb21GaWx0ZXJcbiAgLy8gZHluYW1pYyBlbnRpcmVzIGZpbHRlclxuICBfYmZsX2Q/OiBpbXBvcnQoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKS5CbG9vbUZpbHRlclxuXG4gIHByaXZhdGUgc3RhdGU6IFJlYWRvbmx5PHtcbiAgICByb3V0ZTogc3RyaW5nXG4gICAgcGF0aG5hbWU6IHN0cmluZ1xuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAgIGFzUGF0aDogc3RyaW5nXG4gICAgbG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgaXNQcmV2aWV3OiBib29sZWFuXG4gIH0+XG5cbiAgcHJpdmF0ZSBfa2V5OiBzdHJpbmcgPSBjcmVhdGVLZXkoKVxuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyPFJvdXRlckV2ZW50PiA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICBkb21haW5Mb2NhbGVzLFxuICAgICAgaXNQcmV2aWV3LFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoV3JhcEFwcENvbXBvbmVudDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZVtdXG4gICAgICBpc1ByZXZpZXc/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgIENvbXBvbmVudDogQXBwIGFzIENvbXBvbmVudFR5cGUsXG4gICAgICBzdHlsZVNoZWV0czogW1xuICAgICAgICAvKiAvX2FwcCBkb2VzIG5vdCBuZWVkIGl0cyBzdHlsZXNoZWV0cyBtYW5hZ2VkICovXG4gICAgICBdLFxuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0XG5cbiAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJ1xuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZVxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5pc0V4cGVyaW1lbnRhbENvbXBpbGUgfHxcbiAgICAgIChzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwKSB8fFxuICAgICAgKCFhdXRvRXhwb3J0RHluYW1pYyAmJlxuICAgICAgICAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiZcbiAgICAgICAgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpXG4gICAgKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICByb3V0ZSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcXVlcnksXG4gICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICBjb25zdCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHsgbG9jYWxlIH1cbiAgICAgICAgY29uc3QgYXNQYXRoID0gZ2V0VVJMKClcblxuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgYXNQYXRoLFxuICAgICAgICB9KS50aGVuKChtYXRjaGVzKSA9PiB7XG4gICAgICAgICAgLy8gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHdlIGxlYXZlIHJlc29sdmluZyB0byB0aGUgY2hhbmdlIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gYXMgdGhlIHNlcnZlciBuZWVkcyB0byByZXNvbHZlIGZvciBjb3JyZWN0IHByaW9yaXR5XG4gICAgICAgICAgOyhvcHRpb25zIGFzIGFueSkuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lXG5cbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICAgID8gYXNQYXRoXG4gICAgICAgICAgICAgIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlc1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgfSA9IHRoaXNcbiAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2VcblxuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgIGlmIChcbiAgICAgIGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiZcbiAgICAgIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZvcmNlZFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBrZXkgfSA9IHN0YXRlXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsga2V5KVxuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2ISlcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHsgeDogMCwgeTogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2tleSA9IGtleVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAoXG4gICAgICB0aGlzLmlzU3NyICYmXG4gICAgICBhcyA9PT0gYWRkQmFzZVBhdGgodGhpcy5hc1BhdGgpICYmXG4gICAgICBwYXRobmFtZSA9PT0gYWRkQmFzZVBhdGgodGhpcy5wYXRobmFtZSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ248e30sIFRyYW5zaXRpb25PcHRpb25zLCBUcmFuc2l0aW9uT3B0aW9ucz4oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgIF9oOiAwLFxuICAgICAgfSksXG4gICAgICBmb3JjZWRTY3JvbGxcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGZvcndhcmQgaW4gaGlzdG9yeVxuICAgKi9cbiAgZm9yd2FyZCgpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHJlcGxhY2UodXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBfYmZsKFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcmVzb2x2ZWRBcz86IHN0cmluZyxcbiAgICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgICBza2lwTmF2aWdhdGU/OiBib29sZWFuXG4gICkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgaWYgKCF0aGlzLl9iZmxfcyAmJiAhdGhpcy5fYmZsX2QpIHtcbiAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciB9ID1cbiAgICAgICAgICByZXF1aXJlKCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpXG5cbiAgICAgICAgdHlwZSBGaWx0ZXIgPSBSZXR1cm5UeXBlPFxuICAgICAgICAgIGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpLkJsb29tRmlsdGVyWydleHBvcnQnXVxuICAgICAgICA+XG4gICAgICAgIGxldCBzdGF0aWNGaWx0ZXJEYXRhOiBGaWx0ZXIgfCB1bmRlZmluZWRcbiAgICAgICAgbGV0IGR5bmFtaWNGaWx0ZXJEYXRhOiBGaWx0ZXIgfCB1bmRlZmluZWRcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIDsoe1xuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJTdGF0aWM6IHN0YXRpY0ZpbHRlckRhdGEsXG4gICAgICAgICAgICBfX3JvdXRlckZpbHRlckR5bmFtaWM6IGR5bmFtaWNGaWx0ZXJEYXRhLFxuICAgICAgICAgIH0gPSAoYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKSBhcyBhbnkgYXMge1xuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJTdGF0aWM/OiBGaWx0ZXJcbiAgICAgICAgICAgIF9fcm91dGVyRmlsdGVyRHluYW1pYz86IEZpbHRlclxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGZhaWxlZCB0byBsb2FkIGJ1aWxkIG1hbmlmZXN0IGhhcmQgbmF2aWdhdGVcbiAgICAgICAgICAvLyB0byBiZSBzYWZlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgdXJsOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgYWRkTG9jYWxlKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3V0ZXJGaWx0ZXJTVmFsdWU6IEZpbHRlciB8IGZhbHNlID0gcHJvY2Vzcy5lbnZcbiAgICAgICAgICAuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIgYXMgYW55XG5cbiAgICAgICAgaWYgKCFzdGF0aWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlclNWYWx1ZSkge1xuICAgICAgICAgIHN0YXRpY0ZpbHRlckRhdGEgPSByb3V0ZXJGaWx0ZXJTVmFsdWUgPyByb3V0ZXJGaWx0ZXJTVmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvdXRlckZpbHRlckRWYWx1ZTogRmlsdGVyIHwgZmFsc2UgPSBwcm9jZXNzLmVudlxuICAgICAgICAgIC5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiBhcyBhbnlcblxuICAgICAgICBpZiAoIWR5bmFtaWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlckRWYWx1ZSkge1xuICAgICAgICAgIGR5bmFtaWNGaWx0ZXJEYXRhID0gcm91dGVyRmlsdGVyRFZhbHVlXG4gICAgICAgICAgICA/IHJvdXRlckZpbHRlckRWYWx1ZVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0aWNGaWx0ZXJEYXRhPy5udW1IYXNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihcbiAgICAgICAgICAgIHN0YXRpY0ZpbHRlckRhdGEubnVtSXRlbXMsXG4gICAgICAgICAgICBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkeW5hbWljRmlsdGVyRGF0YT8ubnVtSGFzaGVzKSB7XG4gICAgICAgICAgdGhpcy5fYmZsX2QgPSBuZXcgQmxvb21GaWx0ZXIoXG4gICAgICAgICAgICBkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcyxcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJEYXRhLmVycm9yUmF0ZVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZXNCZmxTdGF0aWMgPSBmYWxzZVxuICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2VcbiAgICAgIGNvbnN0IHBhdGhzVG9DaGVjazogQXJyYXk8eyBhcz86IHN0cmluZzsgYWxsb3dNYXRjaEN1cnJlbnQ/OiBib29sZWFuIH0+ID1cbiAgICAgICAgW3sgYXMgfSwgeyBhczogcmVzb2x2ZWRBcyB9XVxuXG4gICAgICBmb3IgKGNvbnN0IHsgYXM6IGN1ckFzLCBhbGxvd01hdGNoQ3VycmVudCB9IG9mIHBhdGhzVG9DaGVjaykge1xuICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICBjb25zdCBhc05vU2xhc2ggPSByZW1vdmVUcmFpbGluZ1NsYXNoKFxuICAgICAgICAgICAgbmV3IFVSTChjdXJBcywgJ2h0dHA6Ly9uJykucGF0aG5hbWVcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgYXNOb1NsYXNoTG9jYWxlID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBhZGRMb2NhbGUoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWxsb3dNYXRjaEN1cnJlbnQgfHxcbiAgICAgICAgICAgIGFzTm9TbGFzaCAhPT1cbiAgICAgICAgICAgICAgcmVtb3ZlVHJhaWxpbmdTbGFzaChuZXcgVVJMKHRoaXMuYXNQYXRoLCAnaHR0cDovL24nKS5wYXRobmFtZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPVxuICAgICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljIHx8XG4gICAgICAgICAgICAgICEhdGhpcy5fYmZsX3M/LmNvbnRhaW5zKGFzTm9TbGFzaCkgfHxcbiAgICAgICAgICAgICAgISF0aGlzLl9iZmxfcz8uY29udGFpbnMoYXNOb1NsYXNoTG9jYWxlKVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRBUyBvZiBbYXNOb1NsYXNoLCBhc05vU2xhc2hMb2NhbGVdKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGFueSBzdWItcGF0aCBvZiBhcyBtYXRjaGVzIGEgZHluYW1pYyBmaWx0ZXIgcGF0aFxuICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgY29uc3QgY3VyQXNQYXJ0cyA9IG5vcm1hbGl6ZWRBUy5zcGxpdCgnLycpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICFtYXRjaGVzQmZsRHluYW1pYyAmJiBpIDwgY3VyQXNQYXJ0cy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbignLycpXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0ICYmIHRoaXMuX2JmbF9kPy5jb250YWlucyhjdXJyZW50UGFydCkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICAgICAgICBhZGRMb2NhbGUoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybCwgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSAob3B0aW9ucyBhcyBhbnkpLl9oID09PSAxXG5cbiAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpXG4gICAgfVxuXG4gICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID1cbiAgICAgIGlzUXVlcnlVcGRhdGluZyB8fFxuICAgICAgKG9wdGlvbnMgYXMgYW55KS5fc2hvdWxkUmVzb2x2ZUhyZWYgfHxcbiAgICAgIHBhcnNlUGF0aCh1cmwpLnBhdGhuYW1lID09PSBwYXJzZVBhdGgoYXMpLnBhdGhuYW1lXG5cbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnN0YXRlLFxuICAgIH1cblxuICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlXG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzclxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBuZXh0U3RhdGUubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gcmVtb3ZlQmFzZVBhdGgoYXMpIDogYXNcbiAgICAgIClcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpXG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aCh1cmwpID8gcmVtb3ZlQmFzZVBhdGgodXJsKSA6IHVybCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICkucGF0aG5hbWVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2VcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUhKSkge1xuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIHVybDogZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgKVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWROYXZpZ2F0ZSAmJlxuICAgICAgICAgIGRldGVjdGVkRG9tYWluICYmXG4gICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiAmJlxuICAgICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSByZW1vdmVCYXNlUGF0aChhcylcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICB1cmw6IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtcbiAgICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgICB9JHthZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgOiBgLyR7bmV4dFN0YXRlLmxvY2FsZX1gXG4gICAgICAgICAgICAgIH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLydcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSwgc2Nyb2xsID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgICBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksXG4gICAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSxcbiAgICAgICAgICByb3V0ZVByb3BzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIGFzID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IHJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgICBvcHRpb25zLmxvY2FsZSxcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICApXG4gICAgKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IHJlbW92ZUxvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IHJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICB9KVxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChpc0Vycm9yKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogc3RyaW5nW10sIHJld3JpdGVzOiBhbnlcbiAgICB0cnkge1xuICAgICAgO1twYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSxcbiAgICAgIF0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVRyYWlsaW5nU2xhc2gocmVtb3ZlQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgbGV0IHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aCgnLycpICYmIHBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lXG5cbiAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICBpZiAoKHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0gYXMgYW55KT8uX19hcHBSb3V0ZXIpIHtcbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgfVxuXG4gICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKFxuICAgICAgcGFyc2VkQXNQYXRobmFtZSAmJlxuICAgICAgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiZcbiAgICAgICghaXNEeW5hbWljUm91dGUocm91dGUpIHx8XG4gICAgICAgICFnZXRSb3V0ZU1hdGNoZXIoZ2V0Um91dGVSZWdleChyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKVxuICAgIClcblxuICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID1cbiAgICAgICFvcHRpb25zLnNoYWxsb3cgJiZcbiAgICAgIChhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgfSkpXG5cbiAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIDsob3B0aW9ucyBhcyBhbnkpLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWVcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSxcbiAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKVxuXG4gICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKVxuXG4gICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgK1xuICAgICAgICAgICAgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IHJlbW92ZUxvY2FsZShyZW1vdmVCYXNlUGF0aChyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSlcblxuICAgIHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBsZXQgcm91dGVNYXRjaDogUGFyYW1zIHwgZmFsc2UgPSBmYWxzZVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpXG4gICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWVcblxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlXG4gICAgICAgID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpXG4gICAgICAgIDogKHt9IGFzIHsgcmVzdWx0OiB1bmRlZmluZWQ7IHBhcmFtczogdW5kZWZpbmVkIH0pXG5cbiAgICAgIGlmICghcm91dGVNYXRjaCB8fCAoc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gYEludGVycG9sYXRpbmcgaHJlZmBcbiAgICAgICAgICAgICAgICAgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYFxuICAgICAgICAgICAgICB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIChzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYFxuICAgICAgICAgICAgICA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICtcbiAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCdcbiAgICAgICAgICAgICAgICAgIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ1xuICAgICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgcXVlcnk6IG9taXQocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgIH1cblxuICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IHRoaXMucGF0aG5hbWUgPT09ICcvNDA0JyB8fCB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcidcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBhd2FpdCB0aGlzLl9iZmwoXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgJ3Jlc29sdmVkQXMnIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3JvdXRlJyBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGVcbiAgICAgICAgcm91dGUgPSBwYXRobmFtZVxuXG4gICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gaGFzQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKVxuICAgICAgICAgID8gcmVtb3ZlQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKVxuICAgICAgICAgIDogcGFyc2VkLnBhdGhuYW1lXG5cbiAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID1cbiAgICAgICAgICAgICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXNcbiAgICAgICAgICAgICAgPyByb3V0ZUluZm8ucmVzb2x2ZWRBc1xuICAgICAgICAgICAgICA6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgICAgICAgICAgYWRkTG9jYWxlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBc1xuXG4gICAgICAgICAgaWYgKGhhc0Jhc2VQYXRoKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgIHJld3JpdGVBcyA9IHJlbW92ZUJhc2VQYXRoKHJld3JpdGVBcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChyZXdyaXRlQXMsIHRoaXMubG9jYWxlcylcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHBhdGhuYW1lKVxuICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoXG4gICAgICAgICAgICBuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWVcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbiwgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudDogYW55ID0gcm91dGVJbmZvLkNvbXBvbmVudFxuICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKVxuXG4gICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0OiBhbnkpID0+IHtcbiAgICAgICAgICBoYW5kbGVDbGllbnRTY3JpcHRMb2FkKHNjcmlwdC5wcm9wcylcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiZcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZVxuXG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiZcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoXG4gICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHBhZ2VzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwsIGFzOiBuZXdBcyB9ID0gcHJlcGFyZVVybEFzKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBkZXN0aW5hdGlvbiwgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0YXRlLmlzUHJldmlldyA9ICEhcm91dGVJbmZvLnByb3BzLl9fTl9QUkVWSUVXXG5cbiAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICByb3V0ZVByb3BzOiB7IHNoYWxsb3c6IGZhbHNlIH0sXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGlzUXVlcnlVcGRhdGluZyAmJlxuICAgICAgICB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcicgJiZcbiAgICAgICAgc2VsZi5fX05FWFRfREFUQV9fLnByb3BzPy5wYWdlUHJvcHM/LnN0YXR1c0NvZGUgPT09IDUwMCAmJlxuICAgICAgICByb3V0ZUluZm8ucHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMFxuICAgICAgfVxuXG4gICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID1cbiAgICAgICAgb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKHJvdXRlSW5mby5yb3V0ZSA/PyByb3V0ZSlcblxuICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID1cbiAgICAgICAgb3B0aW9ucy5zY3JvbGwgPz8gKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzVmFsaWRTaGFsbG93Um91dGUpXG4gICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHsgeDogMCwgeTogMCB9IDogbnVsbFxuICAgICAgY29uc3QgdXBjb21pbmdTY3JvbGxTdGF0ZSA9IGZvcmNlZFNjcm9sbCA/PyByZXNldFNjcm9sbFxuXG4gICAgICAvLyB0aGUgbmV3IHN0YXRlIHRoYXQgdGhlIHJvdXRlciBnb25uYSBzZXRcbiAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSB7XG4gICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgcm91dGVQcm9wczogeyBzaGFsbG93OiBmYWxzZSB9LFxuICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAke3RoaXMucGF0aG5hbWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcicgJiZcbiAgICAgICAgICBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHM/LnBhZ2VQcm9wcz8uc3RhdHVzQ29kZSA9PT0gNTAwICYmXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzPy5wYWdlUHJvcHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMFxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChpc0Vycm9yKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPVxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmcgJiZcbiAgICAgICAgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiZcbiAgICAgICAgIXJlYWR5U3RhdGVDaGFuZ2UgJiZcbiAgICAgICAgIWxvY2FsZUNoYW5nZSAmJlxuICAgICAgICBjb21wYXJlUm91dGVyU3RhdGVzKHVwY29taW5nUm91dGVyU3RhdGUsIHRoaXMuc3RhdGUpXG5cbiAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlXG4gICAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm91dGVJbmZvLmVycm9yKSB7XG4gICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcbiAgICAgICAgICAgICAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAgICAgICAgICAgICByb3V0ZUluZm8uZXJyb3IsXG4gICAgICAgICAgICAgIGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgcm91dGVQcm9wc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgaGFzaCBtYXJrICMgaXMgdGhlIG9wdGlvbmFsIGxhc3QgcGFydCBvZiBhIFVSTFxuICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC9cbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzRXJyb3IoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBrZXk6ICh0aGlzLl9rZXkgPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KCkpLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU/OiBhbnk7IGNhbmNlbGxlZD86IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKGlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgfSlcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcihlcnIpXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9XG4gICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycixcbiAgICAgICAgZXJyb3I6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgICAgICBpc0Vycm9yKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKHtcbiAgICByb3V0ZTogcmVxdWVzdGVkUm91dGUsXG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnksXG4gICAgYXMsXG4gICAgcmVzb2x2ZWRBcyxcbiAgICByb3V0ZVByb3BzLFxuICAgIGxvY2FsZSxcbiAgICBoYXNNaWRkbGV3YXJlLFxuICAgIGlzUHJldmlldyxcbiAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgaXNRdWVyeVVwZGF0aW5nLFxuICAgIGlzTWlkZGxld2FyZVJld3JpdGUsXG4gICAgaXNOb3RGb3VuZCxcbiAgfToge1xuICAgIHJvdXRlOiBzdHJpbmdcbiAgICBwYXRobmFtZTogc3RyaW5nXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gICAgYXM6IHN0cmluZ1xuICAgIHJlc29sdmVkQXM6IHN0cmluZ1xuICAgIGhhc01pZGRsZXdhcmU/OiBib29sZWFuXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzXG4gICAgbG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpc1ByZXZpZXc6IGJvb2xlYW5cbiAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG4gICAgaXNRdWVyeVVwZGF0aW5nPzogYm9vbGVhblxuICAgIGlzTWlkZGxld2FyZVJld3JpdGU/OiBib29sZWFuXG4gICAgaXNOb3RGb3VuZD86IGJvb2xlYW5cbiAgfSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBleGlzdGluZ0luZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoeyByb3V0ZSwgcm91dGVyOiB0aGlzIH0pXG5cbiAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID1cbiAgICAgICAgZXhpc3RpbmdJbmZvICYmXG4gICAgICAgICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nSW5mbykgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCdcbiAgICAgICAgICA/IGV4aXN0aW5nSW5mb1xuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZ1xuICAgICAgY29uc3QgZmV0Y2hOZXh0RGF0YVBhcmFtczogRmV0Y2hOZXh0RGF0YVBhcmFtcyA9IHtcbiAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgaHJlZjogZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgIH0pLFxuICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgIGlzQmFja2dyb3VuZCxcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGE6XG4gICAgICAgIHwgV2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0XG4gICAgICAgIHwgKFBpY2s8V2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0LCAnanNvbic+ICZcbiAgICAgICAgICAgIE9taXQ8UGFydGlhbDxXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQ+LCAnanNvbic+KVxuICAgICAgICB8IG51bGwgPVxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGVcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgIGZldGNoRGF0YTogKCkgPT4gZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAvLyBlZmZlY3RzXG4gICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09ICcvX2Vycm9yJyB8fCBwYXRobmFtZSA9PT0gJy80MDQnKSkge1xuICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSB7IGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcblxuICAgICAgaWYgKFxuICAgICAgICBkYXRhPy5lZmZlY3Q/LnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcgfHxcbiAgICAgICAgZGF0YT8uZWZmZWN0Py50eXBlID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhPy5lZmZlY3Q/LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICBjb25zdCByZXNvbHZlZFJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgICAgICAvLyBkdXJpbmcgcXVlcnkgdXBkYXRpbmcgdGhlIHBhZ2UgbXVzdCBtYXRjaCBhbHRob3VnaCBkdXJpbmdcbiAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAvLyB3aGljaCBpcyB2YWxpZCBmb3IgaW5jcmVtZW50YWwgbWlncmF0aW9uXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgcm91dGUgPSByZXNvbHZlZFJvdXRlXG4gICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgICBxdWVyeSA9IHsgLi4ucXVlcnksIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5IH1cbiAgICAgICAgICByZXNvbHZlZEFzID0gcmVtb3ZlQmFzZVBhdGgoXG4gICAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpXG4gICAgICAgICAgICAgIC5wYXRobmFtZVxuICAgICAgICAgIClcblxuICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJvdXRlUHJvcHMuc2hhbGxvdyAmJlxuICAgICAgICAgICAgZXhpc3RpbmdJbmZvICYmXG4gICAgICAgICAgICB0aGlzLnJvdXRlID09PSByb3V0ZSAmJlxuICAgICAgICAgICAgIWhhc01pZGRsZXdhcmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uZXhpc3RpbmdJbmZvLCByb3V0ZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FQSVJvdXRlKHJvdXRlKSkge1xuICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8bmV2ZXI+KCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm8gPVxuICAgICAgICBjYWNoZWRSb3V0ZUluZm8gfHxcbiAgICAgICAgKGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW48Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPihcbiAgICAgICAgICAocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSlcbiAgICAgICAgKSlcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhPy5yZXNwb25zZT8uaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1za2lwJylcblxuICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1BcblxuICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoICYmIGRhdGE/LmRhdGFIcmVmKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHByb3BzLCBjYWNoZUtleSB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YT8uanNvbiAmJiAhd2FzQmFpbGVkUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LCBwcm9wczogZGF0YS5qc29uIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkYXRhSHJlZiA9IGRhdGE/LmRhdGFIcmVmXG4gICAgICAgICAgICA/IGRhdGEuZGF0YUhyZWZcbiAgICAgICAgICAgIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICBocmVmOiBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9LFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgcHJvcHM6IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgcm91dGVJbmZvLkNvbXBvbmVudCxcbiAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgKSxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXG4gICAgICAvLyBtaWRkbGV3YXJlIGNhbiBza2lwIGNhY2hlIHBlciByZXF1ZXN0IHdpdGhcbiAgICAgIC8vIHgtbWlkZGxld2FyZS1jYWNoZTogbm8tY2FjaGUgYXMgd2VsbFxuICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYgJiYgY2FjaGVLZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XVxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5pc1ByZXZpZXcgJiZcbiAgICAgICAgcm91dGVJbmZvLl9fTl9TU0cgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgIWlzUXVlcnlVcGRhdGluZ1xuICAgICAgKSB7XG4gICAgICAgIGZldGNoTmV4dERhdGEoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjLFxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4ge30pXG4gICAgICB9XG5cbiAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcylcbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZVxuICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnlcbiAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgZ2V0UHJvcGVyRXJyb3IoZXJyKSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0KFxuICAgIHN0YXRlOiB0eXBlb2YgdGhpcy5zdGF0ZSxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuXG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycsIDIpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycsIDIpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2ggPSAnJ10gPSBhcy5zcGxpdCgnIycsIDIpXG5cbiAgICBoYW5kbGVTbW9vdGhTY3JvbGwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjb2RlIGhhc2ggdG8gbWFrZSBub24tbGF0aW4gYW5jaG9yIHdvcmtzLlxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpXG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKVxuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF1cbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG9ubHlIYXNoQ2hhbmdlOiB0aGlzLm9ubHlBSGFzaENoYW5nZShhcyksXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNCb3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG5cbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBub3JtYWxpemVMb2NhbGVQYXRoIShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG5cbiAgICAgICAgbGV0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoIShcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICBhc1BhdGggPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGhcblxuICAgIGNvbnN0IGxvY2FsZSA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkXG4gICAgICAgIDogdGhpcy5sb2NhbGVcblxuICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICB9KVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgbGV0IHJld3JpdGVzOiBhbnlcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuXG4gICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBwYXJzZWQucXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICByZXNvbHZlZEFzID0gcmVtb3ZlTG9jYWxlKFxuICAgICAgICAgIHJlbW92ZUJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksXG4gICAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcblxuICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcylcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBnZXRSb3V0ZU1hdGNoZXIoZ2V0Um91dGVSZWdleChwYXJzZWQucGF0aG5hbWUpKShcbiAgICAgICAgICBwYXJzZVBhdGgoYXNQYXRoKS5wYXRobmFtZVxuICAgICAgICApIHx8IHt9XG4gICAgICApXG5cbiAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09ICdzdHJpY3QnXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpID0+XG4gICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgaHJlZjogZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovXG4gICAgaWYgKGRhdGE/LmVmZmVjdC50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZlxuICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWZcbiAgICAgIHF1ZXJ5ID0geyAuLi5xdWVyeSwgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkgfVxuICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqL1xuICAgIGlmIChkYXRhPy5lZmZlY3QudHlwZSA9PT0gJ3JlZGlyZWN0LWV4dGVybmFsJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHsgX19hcHBSb3V0ZXI6IHRydWUgfSBhcyBhbnlcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZykgPT4ge1xuICAgICAgICByZXR1cm4gaXNTc2dcbiAgICAgICAgICA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICBkYXRhSHJlZjogZGF0YT8uanNvblxuICAgICAgICAgICAgICAgID8gZGF0YT8uZGF0YUhyZWZcbiAgICAgICAgICAgICAgICA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHxcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5wcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICAgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSlcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZykge1xuICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoeyByb3V0ZSwgcm91dGVyOiB0aGlzIH0pXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcblxuICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG4gICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddXG4gICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwIGFzIEFwcENvbXBvbmVudClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGdldCByb3V0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlXG4gIH1cblxuICBnZXQgcGF0aG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZVxuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeVxuICB9XG5cbiAgZ2V0IGFzUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aFxuICB9XG5cbiAgZ2V0IGxvY2FsZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZVxuICB9XG5cbiAgZ2V0IGlzRmFsbGJhY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFja1xuICB9XG5cbiAgZ2V0IGlzUHJldmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXdcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUtleSIsIlJvdXRlciIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsIk9iamVjdCIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIm1hdGNoZXJzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsInBhdGhuYW1lIiwiYXNQYXRobmFtZSIsInBhcnNlUGF0aCIsImFzUGF0aCIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0IiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiTUFUQ0hFRF9QQVRIX0hFQURFUiIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwiX19yZXdyaXRlcyIsInJld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJyZXNvbHZlUmV3cml0ZXMiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJlZmZlY3QiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiaHJlZiIsIlVSTCIsImxvY2F0aW9uIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiTk9ERV9FTlYiLCJjYXRjaCIsImVyciIsIm1lc3NhZ2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsInJvdXRlIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwicmVsb2FkIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwiX2tleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJjaGFuZ2UiLCJyZXBsYWNlIiwiX2JmbCIsInNraXBOYXZpZ2F0ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiX2JmbF9zIiwiX2JmbF9kIiwiQmxvb21GaWx0ZXIiLCJyZXF1aXJlIiwic3RhdGljRmlsdGVyRGF0YSIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19yb3V0ZXJGaWx0ZXJTdGF0aWMiLCJfX3JvdXRlckZpbHRlckR5bmFtaWMiLCJjb25zb2xlIiwicm91dGVyRmlsdGVyU1ZhbHVlIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJyb3V0ZXJGaWx0ZXJEVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiIsIm51bUhhc2hlcyIsIm51bUl0ZW1zIiwiZXJyb3JSYXRlIiwiaW1wb3J0IiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwicGF0aHNUb0NoZWNrIiwiY3VyQXMiLCJhbGxvd01hdGNoQ3VycmVudCIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsImNvbnRhaW5zIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsImZvcmNlZFNjcm9sbCIsImlzTG9jYWxVUkwiLCJpc1F1ZXJ5VXBkYXRpbmciLCJfaCIsInNoYWxsb3ciLCJzaG91bGRSZXNvbHZlSHJlZiIsIl9zaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsImlzUmVhZHkiLCJpc1NzciIsInByZXZMb2NhbGUiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJkaWROYXZpZ2F0ZSIsImRldGVjdGVkRG9tYWluIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZG9tYWluTG9jYWxlcyIsImlzTG9jYWxlRG9tYWluIiwiaG9zdG5hbWUiLCJkb21haW4iLCJhc05vQmFzZVBhdGgiLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwiX2luRmxpZ2h0Um91dGUiLCJldmVudHMiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwibG9jYWxlQ2hhbmdlIiwib25seUFIYXNoQ2hhbmdlIiwiY2hhbmdlU3RhdGUiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJjb21wb25lbnRzIiwiaXNFcnJvciIsInBhcnNlZCIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsIl9fYXBwUm91dGVyIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJwIiwiZXh0ZXJuYWxEZXN0Iiwicm91dGVNYXRjaCIsInJvdXRlUmVnZXgiLCJzaG91bGRJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsIm1pc3NpbmdQYXJhbXMiLCJrZXlzIiwiZ3JvdXBzIiwiZmlsdGVyIiwicGFyYW0iLCJvcHRpb25hbCIsIndhcm4iLCJvbWl0IiwiaXNFcnJvclJvdXRlIiwicm91dGVJbmZvIiwiZ2V0Um91dGVJbmZvIiwiaXNQcmV2aWV3IiwiaXNGYWxsYmFjayIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJrZXkiLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsIkNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJub3RGb3VuZFJvdXRlIiwiZmV0Y2hDb21wb25lbnQiLCJfIiwiaXNOb3RGb3VuZCIsIl9fTkVYVF9EQVRBX18iLCJzdGF0dXNDb2RlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhc2hSZWdleCIsImdldFVSTCIsIl9zaGFsbG93IiwiX19OIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwic3R5bGVTaGVldHMiLCJnZXRJbml0aWFsUHJvcHMiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJyZXF1ZXN0ZWRSb3V0ZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwic2JjIiwic2RjIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsInNob3VsZEZldGNoRGF0YSIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwic3ViIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIl9icHMiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvbmx5SGFzaENoYW5nZSIsInByZWZldGNoIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiY3R4IiwiQXBwIiwiQXBwVHJlZSIsIl93cmFwQXBwIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFByb3BzIiwid3JhcEFwcCIsInN1YnNjcmlwdGlvbiIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50Iiwib25Qb3BTdGF0ZSIsIl9fTkEiLCJnZXRJdGVtIiwiaW5pdGlhbCIsImF1dG9FeHBvcnREeW5hbWljIiwiYXV0b0V4cG9ydCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJnc3NwIiwiZ2lwIiwiaXNFeHBlcmltZW50YWxDb21waWxlIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJtaXR0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});